 # Que es useState y para que sirve ? 
 useState es el hook basico de React que **permite a un componente funcional tener estado local** . 

 - **Su proposito** : Almacenar y actualizar valores que cambian a lo largo del tiempo y que , al cambiar, provocan que el componente se vuelva a renderizar .
 - **Problema que resuelve** : Antes de los hooks, solo las clases podian tener estado ; useState trae el mismo concepto (estado local) a los componentes funcionales de una forma simple y composable .

 En resumen : **useState() es la memoria reactiva del componente y setState (la funcion reactiva que devuelve) es la forma de actualizar esa memoria** . 

 # Firma / API basica
 ```javascript
 const [state, setState] = useState<T>(initialState);
 ```

- **state**: el valor actual del estado.

- **setState**: función que actualiza el estado. Puede recibir:
    - Un nuevo valor directamente: setState(newValue)
    - Una función actualizadora: setState(prev => newValueDerivedFrom(prev)) — muy importante en muchos casos.

- **initialState**: el valor inicial (o una función lazy que devuelve el valor inicial).

En TypeScript se suele tipar: useState<number>(0) o useState<User | null>(null).

## Que recibe y que retorna exactamente ?

- **Recibe**: un valor inicial (o una función que retorna ese valor inicial).

- **Retorna**: un tuple [value, setter]. Normalmente se usa desestructuración:
 ```javascript
const [count, setCount] = useState(0);
 ```

# Comportamiento esencial : aspectos que se deben entender
1. **Actualizar el state provoca re-render** del componente (React vuelve a ejecutar la función del componente).

2. **setState no muta inmediatamente** la variable local; en realidad programa una actualización. Si inmediatamente después de llamar setState se imprime el valor de state, se vera el valor antiguo. (Para reaccionar a cambios, usar useEffect o confíar en el siguiente render).

3. **React compara por identidad** (usa Object.is) el nuevo valor con el antiguo; si son iguales, se evita un re-render.

    - Ejemplo: setCount(0) cuando count ya es 0 no hará re-render.

4. **Si se pasa un objeto/array, recordar la inmutabilidad**: se tiene que crear una nueva referencia para que React note el cambio (setItems([...items, newItem])).

5. **Batched updates**: React agrupa (batch) actualizaciones en ciertos contextos para evitar renders intermedios. No confiar en que setState aplique sincronamente.

# Formas de inicializar el state

## Valor directo
```javascript
const [count, setCount] = useState(0);
 ```

## Lazy initializer (cuando el calculo inicial es caro)
Si calcular el initialState es costoso, se puede pasar una funcion que se ejecutara **solo en el primer render** : 
```javascript
const [expensive, setExpensive] = useState(() => heavyComputation());
```
Esto evita recalcular en cada render.

# Formas de actualizar el State

## Actualizar con valor directo
```javascript
setCount(5);
```

## Actualizar con funcion (recomendado para actualizaciones basadas en el estado anterior)
```javascript
setCount(prev => prev + 1);
```

- **Por que usar la forma funcional** : evita problemas de *stale closures* cuando se hacen varias actualizaciones en secuencia o dentro de callbacks asincronos.

**Ejemplo donde importa** 
```javascript
// MAL: si se llama esto dos veces en el mismo handler, solo +1 neto
setCount(count + 1);
setCount(count + 1);

// BIEN:
setCount(prev => prev + 1);
setCount(prev => prev + 1); // incrementa dos veces correctamente
```

# Casos de uso tipicos

## Contador simple
```javascript
import React from "react";

export function Counter() {
  const [count, setCount] = useState<number>(0);

  return (
    <div>
      <p>Valor: {count}</p>
      <button onClick={() => setCount(prev => prev + 1)}>+1</button>
    </div>
  );
}
```

## Toggle booleano
```javascript
const [open, setOpen] = useState(false);
const toggle = () => setOpen(prev => !prev);
```

## Input controlado
```javascript
const [name, setName] = useState("");

<input value={name} onChange={e => setName(e.target.value)} />
<p>Escribiste: {name}</p>
```

## Lista dinamica
```javascript
type Item = { id: string; text: string };
const [items, setItems] = useState<Item[]>([]);

const add = (text: string) =>
  setItems(prev => [...prev, { id: cryptoRandomId(), text }]);

const remove = (id: string) =>
  setItems(prev => prev.filter(it => it.id !== id));

const update = (id: string, newText: string) =>
  setItems(prev => prev.map(it => it.id === id ? { ...it, text: newText } : it));
```

# Patrones y decisiones : un state grande o varios estados pequeños ?

- **Recomendacion** : Dividir el estado en trozos independientes cuando tengan responsabilidades separadas .

Ejemplo -> En vez de  :
```javascript
const [state, setState] = useState({ count: 0, text: "", open: false });
```

Es preferible : 
```javascript
const [count, setCount] = useState(0);
const [text, setText] = useState("");
const [open, setOpen] = useState(false);
```

**Ventajas** : actualizaciones mas especificas, mas legible , menos spread copying .

# Errores comunes y como evitarlos
1. **Mutar el state directamente** (ej. items.push(x) y luego setItems(items)) : no. Siempre crear una nueva referencia.

    - Mal: items.push(newItem); setItems(items);

    - Bien: setItems(prev => [...prev, newItem]);

2. **Usar el valor de state justo después de setState esperando ya tener el nuevo valor** : recordar que el cambio se aplicará en el siguiente render. Usar useEffect o la función actualizadora si se depende del valor anterior.

3. **Omitir la forma funcional cuando actualizaciones dependen del estado anterior** : produce bugs con actualizaciones en serie o concurrencia.

4. **Copiar props a state innecesariamente** ("derived state antipattern") : si el valor siempre puede derivarse de props u otros estados, no lo duplicarlo. Si se necesita un value inicial basado en props (por ejemplo, un formulario "uncontrolled → controlled"), hacerlo con cuidado (usar useEffect para sincronizar inicialmente si es necesario).

5. **Re-renderes innecesarios por pasar nuevas referencias a componentes hijos**: si se pasa un objeto o función inline a un hijo (por ejemplo onClick={() => doSomething()} o style={{...}}), el hijo puede re-renderizar aunque no haya cambio lógico. Soluciones: useCallback/useMemo cuando haya necesidad de optimización, o mantener simple hasta que sea necesario.

## Explicacion profunda de error #4
Imaginar que se tiene un componente que recibe props.value . Muchas veces , la tentacion es "copiar" ese prop en un estado local al montar el componente :
```javascript
// ANTIPATRÓN
function MyInput({ value }: { value: string }) {
  const [text, setText] = useState(value); // copiando prop a state

  return (
    <input
      value={text}
      onChange={(e) => setText(e.target.value)}
    />
  );
}
```

¿Qué pasa aquí?

- Si el padre cambia value, el hijo no se entera, porque ya “copió” el valor una vez en el state y quedó desincronizado.
- Ahora se tienen dos fuentes de verdad: el prop value y el state text. Eso lleva a inconsistencias.

### Forma correcta (cuando no se necesita estado)
Si el valor siempre puede venir directametne de props (es decir, el componente no necesita modificarlo internamente) , usar el prop directamente :
```javascript
// Usar prop directamente (sin duplicar en state)
function MyInput({ value, onChange }: { value: string; onChange: (val: string) => void }) {
  return (
    <input
      value={value}
      onChange={(e) => onChange(e.target.value)}
    />
  );
}
```

Aquí el estado vive solo en el padre. El hijo es un “input controlado”: siempre muestra lo que el padre le da y reporta cambios hacia arriba.

### Caso valido para usar state inicial basado en prop
A veces, si se necesita un estado inicial derivado de props, pero luego el estado debe ser manejado localmente . 

Ejemplo : Un formulario que se llena con los datos de un usuario, pero el usuario puede editar los campos de manera local . 
```javascript
type User = { name: string; email: string };

function UserForm({ user }: { user: User }) {
  const [form, setForm] = useState<User>(user); // inicializa con props

  const handleChange = (field: keyof User, value: string) => {
    setForm(prev => ({ ...prev, [field]: value }));
  };

  return (
    <form>
      <input
        value={form.name}
        onChange={e => handleChange("name", e.target.value)}
      />
      <input
        value={form.email}
        onChange={e => handleChange("email", e.target.value)}
      />
    </form>
  );
}
```
Aquí está bien tener form en el state, porque después de inicializarse con props.user, el componente se vuelve dueño del estado. Ya no depende del prop.

### Caso especial : sincronizar con cambios posteriores en props
¿Qué pasa si los props pueden cambiar después y se quiere reflejar esto en el state?

Ejemplo: un formulario que carga datos del servidor y se quiere que cuando user cambie, el formulario se reinicie.

En ese caso se necesita sincronizar explícitamente con useEffect (el cual es otro hook que se vera mas adelante):
```javascript
function UserForm({ user }: { user: User }) {
  const [form, setForm] = useState<User>(user);

  // sincroniza estado cuando cambian las props
  useEffect(() => {
    setForm(user);
  }, [user]);

  // ... igual que antes
}
```